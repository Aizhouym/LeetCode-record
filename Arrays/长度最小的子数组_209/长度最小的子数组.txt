给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：
输入：target = 4, nums = [1,4,4]
输出：1
示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 
提示：
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105
 
进阶：
如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。

解题思路：暴力解法，我们首先可以想到，要找到一个连续的子数组，其中元素之和要大于等于目标target，于是我们可以设定两层循环，第一层循环为数组的起始位置，
          第二层循环为数组的终止位置，只要总和大于target，将当前的数组长度返回为result，break退出循环。起始位置向前进，时间复杂度为O(n^2)
          滑动窗口，我们需要通过一次循环，实现对于整个数组中最小子数组的查找，首先需要确定的是：一层循环的这个值，作为数组的起始索引还是终止索引，
    如果作为起始索引，我们无法知道要如何遍历后面的元素，无法实现查找数组，故循环的变量一定是作为终止索引出现。起始索引则需要自己进行认为定义，我们通过
    whlie循环判断当前窗口之和是否大于target，大于的话返回当前的子数组长度，对result进行判断赋值，最后通过result -= num[i++];实现对初始索引的前进。